{
	// Place your algorithm-go ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BellmanFord": {
		"scope": "go",
		"prefix": "BellmanFord",
		"body": [
			"var ErrBellmanFordOutOfRange = errors.New(\"BellmanFord: index out of range\")",
			"",
			"type BellmanFord[T constraints.Integer | constraints.Float] struct {",
			"\tvn  int",
			"\tg   []*bellmanFordEdge[T]",
			"\td   []T",
			"\tpre []int",
			"\tinf T",
			"}",
			"",
			"type bellmanFordEdge[T constraints.Integer | constraints.Float] struct {",
			"\tfrom int",
			"\tto   int",
			"\tcost T",
			"}",
			"",
			"func NewBellmanFord[T constraints.Integer | constraints.Float](n int, inf T) *BellmanFord[T] {",
			"\td := make([]T, n)",
			"\tpre := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\td[i] = inf",
			"\t\tpre[i] = -1",
			"\t}",
			"\treturn &BellmanFord[T]{",
			"\t\tvn:  n,",
			"\t\tg:   []*bellmanFordEdge[T]{},",
			"\t\td:   d,",
			"\t\tpre: pre,",
			"\t\tinf: inf,",
			"\t}",
			"}",
			"",
			"func NewDefaultBellmanFord(n int) *BellmanFord[int] {",
			"\treturn NewBellmanFord(n, math.MaxInt)",
			"}",
			"",
			"func (b *BellmanFord[T]) Infinity() T {",
			"\treturn b.inf",
			"}",
			"",
			"func (b *BellmanFord[T]) Order() int {",
			"\treturn b.vn",
			"}",
			"",
			"func (b *BellmanFord[T]) AddEdge(from, to int, cost T) {",
			"\tif !(0 <= from && from < b.Order() && 0 <= to && to < b.Order()) {",
			"\t\tpanic(ErrBellmanFordOutOfRange)",
			"\t}",
			"\tb.g = append(b.g, &bellmanFordEdge[T]{",
			"\t\tfrom: from,",
			"\t\tto:   to,",
			"\t\tcost: cost,",
			"\t})",
			"}",
			"",
			"func (b *BellmanFord[T]) FindNegativeCycle() bool {",
			"\tnd := make([]T, b.Order())",
			"\tfor i := 0; i < b.Order(); i++ {",
			"\t\tupdate := false",
			"\t\tfor _, edge := range b.g {",
			"\t\t\tif nd[edge.to] > nd[edge.from]+edge.cost {",
			"\t\t\t\tnd[edge.to] = nd[edge.from] + edge.cost",
			"\t\t\t\tupdate = true",
			"\t\t\t}",
			"\t\t}",
			"\t\tif !update {",
			"\t\t\treturn false // non negative cycle",
			"\t\t}",
			"\t}",
			"\treturn true // find negative cycle",
			"}",
			"",
			"func (b *BellmanFord[T]) BellmanFord(s int) bool {",
			"\tif !(0 <= s && s < b.Order()) {",
			"\t\tpanic(ErrBellmanFordOutOfRange)",
			"\t}",
			"\tfor i := 0; i < b.Order(); i++ {",
			"\t\tb.d[i] = b.Infinity()",
			"\t\tb.pre[i] = -1",
			"\t}",
			"\tb.d[s] = 0",
			"\tfor i := 0; i < b.Order(); i++ {",
			"\t\tupdate := false",
			"\t\tfor _, edge := range b.g {",
			"\t\t\tif b.d[edge.from] == b.Infinity() {",
			"\t\t\t\tcontinue",
			"\t\t\t}",
			"\t\t\tif b.d[edge.to] > b.d[edge.from]+edge.cost {",
			"\t\t\t\tb.d[edge.to] = b.d[edge.from] + edge.cost",
			"\t\t\t\tb.pre[edge.to] = edge.from",
			"\t\t\t\tupdate = true",
			"\t\t\t}",
			"\t\t}",
			"\t\tif !update {",
			"\t\t\treturn false // non negative cycle",
			"\t\t}",
			"\t}",
			"\tfor i := 0; i < b.Order(); i++ {",
			"\t\tupdate := false",
			"\t\tfor _, edge := range b.g {",
			"\t\t\tif b.d[edge.from] == b.Infinity() || b.d[edge.to] == -b.Infinity() {",
			"\t\t\t\tcontinue",
			"\t\t\t}",
			"\t\t\tif b.d[edge.from] == -b.Infinity() || b.d[edge.to] > b.d[edge.from]+edge.cost {",
			"\t\t\t\tb.d[edge.to] = -b.Infinity()",
			"\t\t\t\tupdate = true",
			"\t\t\t}",
			"\t\t}",
			"\t\tif !update {",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\treturn true // find negative cycle",
			"}",
			"",
			"func (b *BellmanFord[T]) Distance(t int) T {",
			"\tif !(0 <= t && t < b.Order()) {",
			"\t\tpanic(ErrBellmanFordOutOfRange)",
			"\t}",
			"\treturn b.d[t]",
			"}",
			"",
			"func (b *BellmanFord[T]) ShortestPath(t int) []int {",
			"\tif !(0 <= t && t < b.Order()) {",
			"\t\tpanic(ErrBellmanFordOutOfRange)",
			"\t}",
			"\tvar path []int",
			"\tif b.Distance(t) == b.Infinity() || b.Distance(t) == -b.Infinity() {",
			"\t\treturn path",
			"\t}",
			"\tfor t != -1 {",
			"\t\tpath = append(path, t)",
			"\t\tt = b.pre[t]",
			"\t}",
			"\tfor i := 0; i < len(path)/2; i++ {",
			"\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
			"\t}",
			"\treturn path",
			"}"
		],
		"description": ""
	},
	"BinaryHeap": {
		"scope": "go",
		"prefix": "BinaryHeap",
		"body": [
			"var ErrBinaryHeapEmpty = errors.New(\"BinaryHeap: binary-heap is empty\")",
			"",
			"type BinaryHeap[T any] struct {",
			"\tcomp BinaryHeapCompFunc[T]",
			"\ttree []T",
			"}",
			"",
			"type BinaryHeapCompFunc[T any] func(a, b T) bool",
			"",
			"func NewBinaryHeap[T any](f BinaryHeapCompFunc[T]) *BinaryHeap[T] {",
			"\treturn &BinaryHeap[T]{",
			"\t\tcomp: f,",
			"\t\ttree: make([]T, 1),",
			"\t}",
			"}",
			"",
			"func NewDefaultBinaryHeap[T constraints.Ordered]() *BinaryHeap[T] {",
			"\treturn NewBinaryHeap(func(a, b T) bool {",
			"\t\treturn a > b",
			"\t})",
			"}",
			"",
			"func (b *BinaryHeap[T]) shiftUp(i int) {",
			"\tp := i >> 1",
			"\tfor 1 <= p {",
			"\t\tif b.comp(b.tree[p], b.tree[i]) {",
			"\t\t\tbreak",
			"\t\t}",
			"\t\tb.tree[p], b.tree[i] = b.tree[i], b.tree[p]",
			"\t\ti = p",
			"\t\tp >>= 1",
			"\t}",
			"}",
			"",
			"func (b *BinaryHeap[T]) shiftDown(i int) {",
			"\tl, r := i<<1, i<<1|1",
			"\tfor l <= b.Size() {",
			"\t\tif b.Size() < r || b.comp(b.tree[l], b.tree[r]) {",
			"\t\t\tif b.comp(b.tree[i], b.tree[l]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\tb.tree[i], b.tree[l] = b.tree[l], b.tree[i]",
			"\t\t\ti = l",
			"\t\t} else {",
			"\t\t\tif b.comp(b.tree[i], b.tree[r]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\tb.tree[i], b.tree[r] = b.tree[r], b.tree[i]",
			"\t\t\ti = r",
			"\t\t}",
			"\t\tl, r = i<<1, i<<1|1",
			"\t}",
			"}",
			"",
			"func (b *BinaryHeap[T]) Empty() bool {",
			"\treturn b.Size() == 0",
			"}",
			"",
			"func (b *BinaryHeap[T]) Size() int {",
			"\treturn len(b.tree) - 1",
			"}",
			"",
			"func (b *BinaryHeap[T]) Top() T {",
			"\tif b.Empty() {",
			"\t\tpanic(ErrBinaryHeapEmpty)",
			"\t}",
			"\treturn b.tree[1]",
			"}",
			"",
			"func (b *BinaryHeap[T]) Push(x T) {",
			"\tb.tree = append(b.tree, x)",
			"\tb.shiftUp(b.Size())",
			"}",
			"",
			"func (b *BinaryHeap[T]) Pop() T {",
			"\tif b.Empty() {",
			"\t\tpanic(ErrBinaryHeapEmpty)",
			"\t}",
			"\tres := b.tree[1]",
			"\tb.tree[1] = b.tree[b.Size()]",
			"\tb.tree = b.tree[:len(b.tree)-1]",
			"\tif !b.Empty() {",
			"\t\tb.shiftDown(1)",
			"\t}",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"Deque": {
		"scope": "go",
		"prefix": "Deque",
		"body": [
			"var ErrDequeEmpty = errors.New(\"Deque: deque is empty\")",
			"",
			"type Deque[T any] struct {",
			"\tData *list.List",
			"}",
			"",
			"func NewDeque[T any]() *Deque[T] {",
			"\treturn &Deque[T]{Data: list.New()}",
			"}",
			"",
			"func (dq *Deque[T]) Empty() bool {",
			"\treturn dq.Size() == 0",
			"}",
			"",
			"func (dq *Deque[T]) Size() int {",
			"\treturn dq.Data.Len()",
			"}",
			"",
			"func (dq *Deque[T]) Front() T {",
			"\tres := dq.Data.Front()",
			"\tif res == nil {",
			"\t\tpanic(ErrDequeEmpty)",
			"\t}",
			"\treturn res.Value.(T)",
			"}",
			"",
			"func (dq *Deque[T]) Back() T {",
			"\tres := dq.Data.Back()",
			"\tif res == nil {",
			"\t\tpanic(ErrDequeEmpty)",
			"\t}",
			"\treturn res.Value.(T)",
			"}",
			"",
			"func (dq *Deque[T]) PushFront(x T) {",
			"\tdq.Data.PushFront(x)",
			"}",
			"",
			"func (dq *Deque[T]) PushFrontRange(v []T) {",
			"\tfor i := len(v) - 1; i >= 0; i-- {",
			"\t\tdq.Data.PushFront(v[i])",
			"\t}",
			"}",
			"",
			"func (dq *Deque[T]) PushBack(x T) {",
			"\tdq.Data.PushBack(x)",
			"}",
			"",
			"func (dq *Deque[T]) PushBackRange(v []T) {",
			"\tfor i := 0; i < len(v); i++ {",
			"\t\tdq.Data.PushBack(v[i])",
			"\t}",
			"}",
			"",
			"func (dq *Deque[T]) PopFront() T {",
			"\tres := dq.Data.Front()",
			"\tif res == nil {",
			"\t\tpanic(ErrDequeEmpty)",
			"\t}",
			"\treturn dq.Data.Remove(res).(T)",
			"}",
			"",
			"func (dq *Deque[T]) PopBack() T {",
			"\tres := dq.Data.Back()",
			"\tif res == nil {",
			"\t\tpanic(ErrDequeEmpty)",
			"\t}",
			"\treturn dq.Data.Remove(res).(T)",
			"}"
		],
		"description": ""
	},
	"Dijkstra": {
		"scope": "go",
		"prefix": "Dijkstra",
		"body": [
			"var ErrDijkstraOutOfRange = errors.New(\"Dijkstra: index out of range\")",
			"",
			"type Dijkstra[T constraints.Integer | constraints.Float] struct {",
			"\tg   [][]*dijkstraPair[T] // pair of (cost, to)",
			"\td   []T",
			"\tpre []int",
			"\tinf T",
			"}",
			"",
			"type dijkstraPair[T any] struct {",
			"\tfirst  T",
			"\tsecond int",
			"}",
			"",
			"func NewDijkstra[T constraints.Integer | constraints.Float](n int, inf T) *Dijkstra[T] {",
			"\td := make([]T, n)",
			"\tpre := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\td[i] = inf",
			"\t\tpre[i] = -1",
			"\t}",
			"\treturn &Dijkstra[T]{",
			"\t\tg:   make([][]*dijkstraPair[T], n),",
			"\t\td:   d,",
			"\t\tpre: pre,",
			"\t\tinf: inf,",
			"\t}",
			"}",
			"",
			"func NewDefaultDijkstra(n int) *Dijkstra[int] {",
			"\treturn NewDijkstra(n, math.MaxInt)",
			"}",
			"",
			"func (d *Dijkstra[T]) Infinity() T {",
			"\treturn d.inf",
			"}",
			"",
			"func (d *Dijkstra[T]) Order() int {",
			"\treturn len(d.g)",
			"}",
			"",
			"func (d *Dijkstra[T]) AddEdge(from, to int, cost T) {",
			"\tif !(0 <= from && from < d.Order() && 0 <= to && to < d.Order()) {",
			"\t\tpanic(ErrDijkstraOutOfRange)",
			"\t}",
			"\td.g[from] = append(d.g[from], &dijkstraPair[T]{",
			"\t\tfirst:  cost,",
			"\t\tsecond: to,",
			"\t})",
			"}",
			"",
			"func (d *Dijkstra[T]) Dijkstra(s int) {",
			"\tif !(0 <= s && s < d.Order()) {",
			"\t\tpanic(ErrDijkstraOutOfRange)",
			"\t}",
			"\tfor i := 0; i < d.Order(); i++ {",
			"\t\td.d[i] = d.Infinity()",
			"\t\td.pre[i] = -1",
			"\t}",
			"\td.d[s] = 0",
			"\tpq := NewBinaryHeap(func(a, b *dijkstraPair[T]) bool {",
			"\t\treturn a.first < b.first",
			"\t})",
			"\tpq.Push(&dijkstraPair[T]{",
			"\t\tfirst:  0, // dist",
			"\t\tsecond: s, // node",
			"\t})",
			"\tfor !pq.Empty() {",
			"\t\tsrc := pq.Pop()",
			"\t\tif d.d[src.second] < src.first {",
			"\t\t\tcontinue",
			"\t\t}",
			"\t\tfor _, edge := range d.g[src.second] {",
			"\t\t\tif d.d[edge.second] > d.d[src.second]+edge.first {",
			"\t\t\t\td.d[edge.second] = d.d[src.second] + edge.first",
			"\t\t\t\td.pre[edge.second] = src.second",
			"\t\t\t\tpq.Push(&dijkstraPair[T]{",
			"\t\t\t\t\tfirst:  d.d[edge.second],",
			"\t\t\t\t\tsecond: edge.second,",
			"\t\t\t\t})",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"",
			"func (d *Dijkstra[T]) Distance(t int) T {",
			"\tif !(0 <= t && t < d.Order()) {",
			"\t\tpanic(ErrDijkstraOutOfRange)",
			"\t}",
			"\treturn d.d[t]",
			"}",
			"",
			"func (d *Dijkstra[T]) ShortestPath(t int) []int {",
			"\tif !(0 <= t && t < d.Order()) {",
			"\t\tpanic(ErrDijkstraOutOfRange)",
			"\t}",
			"\tvar path []int",
			"\tif d.Distance(t) == d.Infinity() {",
			"\t\treturn path",
			"\t}",
			"\tfor t != -1 {",
			"\t\tpath = append(path, t)",
			"\t\tt = d.pre[t]",
			"\t}",
			"\tfor i := 0; i < len(path)/2; i++ {",
			"\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
			"\t}",
			"\treturn path",
			"}"
		],
		"description": ""
	},
	"Queue": {
		"scope": "go",
		"prefix": "Queue",
		"body": [
			"var ErrQueueEmpty = errors.New(\"Queue: queue is empty\")",
			"",
			"type Queue[T any] struct {",
			"\tData []T",
			"}",
			"",
			"func NewQueue[T any]() *Queue[T] {",
			"\treturn &Queue[T]{Data: []T{}}",
			"}",
			"",
			"func (q *Queue[T]) Empty() bool {",
			"\treturn q.Size() == 0",
			"}",
			"",
			"func (q *Queue[T]) Size() int {",
			"\treturn len(q.Data)",
			"}",
			"",
			"func (q *Queue[T]) Front() T {",
			"\tif q.Empty() {",
			"\t\tpanic(ErrQueueEmpty)",
			"\t}",
			"\treturn q.Data[0]",
			"}",
			"",
			"func (q *Queue[T]) Push(x T) {",
			"\tq.Data = append(q.Data, x)",
			"}",
			"",
			"func (q *Queue[T]) PushRange(v []T) {",
			"\tfor i := 0; i < len(v); i++ {",
			"\t\tq.Data = append(q.Data, v[i])",
			"\t}",
			"}",
			"",
			"func (q *Queue[T]) Pop() T {",
			"\tif q.Empty() {",
			"\t\tpanic(ErrQueueEmpty)",
			"\t}",
			"\tres := q.Data[0]",
			"\tq.Data = q.Data[1:]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"Stack": {
		"scope": "go",
		"prefix": "Stack",
		"body": [
			"var ErrStackEmpty = errors.New(\"Stack: stack is empty\")",
			"",
			"type Stack[T any] struct {",
			"\tData []T",
			"}",
			"",
			"func NewStack[T any]() *Stack[T] {",
			"\treturn &Stack[T]{Data: []T{}}",
			"}",
			"",
			"func (s *Stack[T]) Empty() bool {",
			"\treturn s.Size() == 0",
			"}",
			"",
			"func (s *Stack[T]) Size() int {",
			"\treturn len(s.Data)",
			"}",
			"",
			"func (s *Stack[T]) Top() T {",
			"\tif s.Empty() {",
			"\t\tpanic(ErrStackEmpty)",
			"\t}",
			"\treturn s.Data[len(s.Data)-1]",
			"}",
			"",
			"func (s *Stack[T]) Push(x T) {",
			"\ts.Data = append(s.Data, x)",
			"}",
			"",
			"func (s *Stack[T]) PushRange(v []T) {",
			"\tfor i := 0; i < len(v); i++ {",
			"\t\ts.Data = append(s.Data, v[i])",
			"\t}",
			"}",
			"",
			"func (s *Stack[T]) Pop() T {",
			"\tif s.Empty() {",
			"\t\tpanic(ErrStackEmpty)",
			"\t}",
			"\tres := s.Data[len(s.Data)-1]",
			"\ts.Data = s.Data[:len(s.Data)-1]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"UnionFind": {
		"scope": "go",
		"prefix": "UnionFind",
		"body": [
			"var ErrUnionFindOutOfRange = errors.New(\"UnionFind: index out of range\")",
			"",
			"type UnionFind struct {",
			"\tpar []int",
			"\tgn  int",
			"}",
			"",
			"func NewUnionFind(n int) *UnionFind {",
			"\tpar := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tpar[i] = -1",
			"\t}",
			"\treturn &UnionFind{",
			"\t\tpar: par,",
			"\t\tgn:  n,",
			"\t}",
			"}",
			"",
			"func (uf *UnionFind) Vn() int {",
			"\treturn len(uf.par)",
			"}",
			"",
			"func (uf *UnionFind) Gn() int {",
			"\treturn uf.gn",
			"}",
			"",
			"func (uf *UnionFind) Root(x int) int {",
			"\tif !(0 <= x && x < uf.Vn()) {",
			"\t\tpanic(ErrUnionFindOutOfRange)",
			"\t}",
			"\tif uf.par[x] < 0 {",
			"\t\treturn x",
			"\t}",
			"\treturn uf.Root(uf.par[x])",
			"}",
			"",
			"func (uf *UnionFind) Size(x int) int {",
			"\tif !(0 <= x && x < uf.Vn()) {",
			"\t\tpanic(ErrUnionFindOutOfRange)",
			"\t}",
			"\treturn -uf.par[uf.Root(x)]",
			"}",
			"",
			"func (uf *UnionFind) IsSame(x, y int) bool {",
			"\tif !(0 <= x && x < uf.Vn() && 0 <= y && y < uf.Vn()) {",
			"\t\tpanic(ErrUnionFindOutOfRange)",
			"\t}",
			"\treturn uf.Root(x) == uf.Root(y)",
			"}",
			"",
			"func (uf *UnionFind) Unite(x, y int) bool {",
			"\tif !(0 <= x && x < uf.Vn() && 0 <= y && y < uf.Vn()) {",
			"\t\tpanic(ErrUnionFindOutOfRange)",
			"\t}",
			"\tx, y = uf.Root(x), uf.Root(y)",
			"\tif x == y {",
			"\t\treturn false",
			"\t}",
			"\tif uf.Size(x) < uf.Size(y) {",
			"\t\tx, y = y, x",
			"\t}",
			"\tuf.par[x] += uf.par[y]",
			"\tuf.par[y] = x",
			"\tuf.gn--",
			"\treturn true",
			"}",
			"",
			"func (uf *UnionFind) Reset() {",
			"\tfor i := 0; i < uf.Vn(); i++ {",
			"\t\tuf.par[i] = -1",
			"\t}",
			"\tuf.gn = uf.Vn()",
			"}"
		],
		"description": ""
	}
}